//+------------------------------------------------------------------+
//|                                                EA_Tendencial.mq4 |
//|                                  Copyright 2023, MetaQuotes Ltd. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2023, MetaQuotes Ltd."
#property link      "https://www.mql5.com"
#property version   "1.00"
#property strict
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//---
   
//---
   return(INIT_SUCCEEDED);
  }
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//---
   
  }
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------
input double lots = 0.10;
double lot = lots;

double open_tick = Close[1];

double trade_long = open_tick;
double trade_short = open_tick;

int distancia = 300;
int stop_loss = 100;

bool trade = true;
bool _long = true;
bool _short = true;

void OnTick() {

    MqlTick last_tick;
    SymbolInfoTick(Symbol(), last_tick);
    
    if( trade == true && last_tick.ask >= trade_long + NormalizeDouble(distancia*Point,Digits)){
    
        OrderSend(Symbol(),OP_BUY,lot,Ask,5,last_tick.ask - NormalizeDouble(stop_loss*Point,Digits),0,"Posicion larga abierta",12345,0,Blue)
        trade_long += NormalizeDouble(distancia*Point,Digits);
        trade_short = trade_long;
    }
    
    if( trade == true && last_tick.bid <= trade_short - NormalizeDouble(distancia*Point,Digits)){
    
        OrderSend(Symbol(),OP_SELL,lot,Bid,5,last_tick.bid + NormalizeDouble(stop_loss*Point,Digits),0,"Posicion corta abierta",12345,0,Blue)
        trade_short += NormalizeDouble(distancia*Point,Digits);
        trade_long = trade_short;
    }
   
}
//+------------------------------------------------------------------+
bool stop_open_positions(double storage_1[][], double storage_2){
    
    int rango = 50;
    MqlTick last_tic;
    SymbolInfoTick(Symbol(), last_tic);
    
    for(int i = 0; i <= OrdersTotal(); i++){
    
       if(!OrderSelect(i,SELECT_BY_POS,MODE_TRADES)
           continue;
           
       if (OrderSymbol() == Symbol()){
       
            if (OrderType() == OP_BUY){
                for (int g = 0; g <= 1000; g++){
                    for (int h = 0; h <= 1000; h++) {
                        if (last_tic.ask <= storage_1[0][g] + NormalizeDouble(rango*Point,Digits) &&
                            last_tic.ask >= storage_1[0][g] - NormalizeDouble(rango*Point,Digits) &&
                            last_tic.ask <= storage_2[0][h] + NormalizeDouble(rango*Point,Digits) &&
                            last_tic.ask >= storage_2[0][h] - NormalizeDouble(rango*Point,Digits)){
                            return trade = false;
                            }
                    }
                }
            }
            
            if (OrderType() == OP_SELL){
                for ( g = 0; g <= 1000; g++){
                    for ( h = 0; h <= 1000; h++) {
                        if (last_tic.bid <= storage_1[0][g] + NormalizeDouble(rango*Point,Digits) &&
                            last_tic.bid >= storage_1[0][g] - NormalizeDouble(rango*Point,Digits) &&
                            last_tic.bid <= storage_2[0][h] + NormalizeDouble(rango*Point,Digits) &&
                            last_tic.bid >= storage_2[0][h] - NormalizeDouble(rango*Point,Digits)){
                            return trade = false;
                            }
                    }
                }
            }
            else{
               return trade = true
            }
        }
    }
    return trade = true;
}

bool stop_open_positions_long(){
    
    int rango = 80;
    MqlTick last_tic;
    SymbolInfoTick(Symbol(), last_tic);
    
    for(int i = 0; i <= OrdersTotal(); i++){
    
       if(!OrderSelect(i,SELECT_BY_POS,MODE_TRADES)
           continue;
           
       if (OrderSymbol() == Symbol()){
       
            if (OrderType() == OP_BUY){
                if (last_tic.ask <= OrderOpenPrice() +  NormalizeDouble(rango*Point,Digits) &&
                    last_tic.ask >= OrderOpenPrice() -  NormalizeDouble(rango*Point,Digits)){
                        return _long = false;
                }
                else {
                   return _long = true;
                }
                
            }
        }
    }
}

bool stop_open_positions_long(){
    
    int rango = 80;
    MqlTick last_tic;
    SymbolInfoTick(Symbol(), last_tic);
    
    for(int i = 0; i <= OrdersTotal(); i++){
    
       if(!OrderSelect(i,SELECT_BY_POS,MODE_TRADES)
           continue;
           
       if (OrderSymbol() == Symbol()){
       
            if (OrderType() == OP_BUY){
                if (last_tic.ask <= OrderOpenPrice() +  NormalizeDouble(rango*Point,Digits) &&
                    last_tic.ask >= OrderOpenPrice() -  NormalizeDouble(rango*Point,Digits)){
                        return _long = false;
                }
                else {
                   return _long = true;
                }
                
            }
        }
    }
}

bool stop_open_positions_long(){
    
    int rango = 80;
    MqlTick last_tic;
    SymbolInfoTick(Symbol(), last_tic);
    
    for(int i = 0; i <= OrdersTotal(); i++){
    
       if(!OrderSelect(i,SELECT_BY_POS,MODE_TRADES)
           continue;
           
       if (OrderSymbol() == Symbol()){
       
            if (OrderType() == OP_SELL){
                if (last_tic.bid <= OrderOpenPrice() +  NormalizeDouble(rango*Point,Digits) &&
                    last_tic.bid >= OrderOpenPrice() -  NormalizeDouble(rango*Point,Digits)){
                        return _short = false;
                }
                else {
                   return _short = true;
                }
                
            }
        }
    }
}


double[][] storage_buy_buffer(){
    
    double storage[][];
    int rango = 80;
    MqlTick last_tic;
    SymbolInfoTick(Symbol(), last_tic);
    
    for(int i = 0; i <= OrdersTotal(); i++){
    
       if(!OrderSelect(i,SELECT_BY_POS,MODE_TRADES)
           continue;
           
       if (OrderSymbol() == Symbol()){
       
            if (OrderType() == OP_BUY){
                for (int g = 0; g <= 1000; g++){
                    if (last_tic.ask <= OrderOpenPrice() + NormalizeDouble(rango*Point,Digits) &&
                        last_tic.ask >= OrderOpenPrice() - NormalizeDouble(rango*Point,Digits)){
                            storage[0][g] = OrderOpenPrice()                               
                        }
                    }
                 }
             }
        }
    }
    return storage;   
}


double[][] storage_sell_buffer(double storage_1[][]){
    
    double storage[][];
    int rango = 80;
    MqlTick last_tic;
    SymbolInfoTick(Symbol(), last_tic);
    
    for(int i = 0; i <= OrdersTotal(); i++){
    
       if(!OrderSelect(i,SELECT_BY_POS,MODE_TRADES)
           continue;
           
       if (OrderSymbol() == Symbol()){
       
            if (OrderType() == OP_SELL){
                for (int g = 0; g <= 1000; g++){
                    if (last_tic.ask <= storage_1[0][g] + NormalizeDouble(rango*Point,Digits) &&
                        last_tic.ask >= storage_1[0][g] - NormalizeDouble(rango*Point,Digits) &&
                        last_tic.bid <= OrderOpenPrice() + NormalizeDouble(rango*Point,Digits) &&
                        last_tic.bid >= OrderOpenPrice() - NormalizeDouble(rango*Point,Digits)){
                            storage[0][g] = OrderOpenPrice()                               
                        }
                    }
                 }
             }
        }
    }
    return storage;
   
}
